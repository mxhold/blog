<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-01-09T18:47:17-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Max’s Thoughts</title><subtitle>Blog for the web developer (and pastry enthusiast) Maxwell Holder</subtitle><author><name>Maxwell Holder</name></author><entry><title type="html">Database migration strategies</title><link href="http://localhost:4000/2019/01/09/database-migration-strategies.html" rel="alternate" type="text/html" title="Database migration strategies" /><published>2019-01-09T14:24:37-08:00</published><updated>2019-01-09T14:24:37-08:00</updated><id>http://localhost:4000/2019/01/09/database-migration-strategies</id><content type="html" xml:base="http://localhost:4000/2019/01/09/database-migration-strategies.html">&lt;p&gt;Most web applications use a database to persist state.
Since the database is separate from the application and changes cannot be made to both simultaneously, there are various strategies for keeping them in sync.&lt;/p&gt;

&lt;h2 id=&quot;fully-coupled&quot;&gt;Fully-coupled&lt;/h2&gt;

&lt;p&gt;Many web applications are deployed by:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;stopping the application&lt;/li&gt;
  &lt;li&gt;running any database migrations&lt;/li&gt;
  &lt;li&gt;deploying and starting the new application&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If a problem is discovered during the deploy, the database change must be rolled back and the old version of the application must be redeployed.&lt;/p&gt;

&lt;p&gt;This is a simple approach that does not require backwards- or forwards-compatibility between the old and new application and database versions since it is assumed that both the application and database will be running either the old or new versions.&lt;/p&gt;

&lt;p&gt;A downside to this approach is that it requires the application to go offline during deploys, causing some period of unavailability.&lt;/p&gt;

&lt;h2 id=&quot;partially-coupled&quot;&gt;Partially-coupled&lt;/h2&gt;

&lt;p&gt;In order to provide zero-downtime deployments, another strategy exists involving &lt;a href=&quot;https://martinfowler.com/bliki/BlueGreenDeployment.html&quot;&gt;blue-green deployment&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;pre-deploy-migrations&quot;&gt;Pre-deploy migrations&lt;/h3&gt;

&lt;p&gt;An example of such an approach could involve multiple application servers running against a single database instance where during a deploy:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;the database is migrated to the new version&lt;/li&gt;
  &lt;li&gt;the new application is deployed to application servers in groups and bounced so that at any one time some servers are running the old application code and the new application code&lt;/li&gt;
  &lt;li&gt;until eventually all application servers are running the new application code&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since multiple application servers are used and at any point in time at least some are running, there is no period of unavailability.&lt;/p&gt;

&lt;p&gt;This approach requires the new database version to be backwards-compatible with the old application version (which would be equivalent to saying the old application version must be forwards-compatible with the new database version) since any server could be running either the old or new application code.&lt;/p&gt;

&lt;p&gt;This approach does &lt;em&gt;not&lt;/em&gt; require the old database version to be forwards-compatible with the new application version (which would be equivalent to saying the new application version does not have to be backwards-compatible with the old database version) since it can always be assumed that if an application server is running the new code, the database changes have already be made due to the fact that the database migration is always run prior to deploying the new code.&lt;/p&gt;

&lt;p&gt;However this also means that if a problem is discovered after the deploy and the database needs to be rolled back, the application &lt;em&gt;must also&lt;/em&gt; be rolled back first.&lt;/p&gt;

&lt;p&gt;A downside to this approach is that it still requires database migrations to be run prior to application deploys, which means long-running database migrations can hold up application deploys.&lt;/p&gt;

&lt;h3 id=&quot;post-deploy-migrations&quot;&gt;Post-deploy migrations&lt;/h3&gt;

&lt;p&gt;An alternative to this approach could be to reverse the order and do database migrations at the end of deploys, which would invert the backwards- and forwards-compatibility.
That is, it would require the new application version to be backwards-compatible with the old database version (but not require the new database version to be backwards-compatible with the old application version).&lt;/p&gt;

&lt;p&gt;This also means that if a problem is discovered after the deploy and the application needs to be rolled back, the database &lt;em&gt;must also&lt;/em&gt; be rolled back.&lt;/p&gt;

&lt;p&gt;However, the problem of database migrations holding up a deploy still applies in either case; it would just be shifted to happening later.&lt;/p&gt;

&lt;p&gt;This alternative is not usually chosen since additive changes are more common.
Consider the example of adding a new column.&lt;/p&gt;

&lt;p&gt;In the pre-migration approach, the database change happens first and then the new application code is deployed.
This means the new application code can then assume that the column will be present (though of course the old application code still needs to work with and without the new column but this is usually easily done e.g. by selecting specific columns instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;select *&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;In the post-migration approach, the new application code cannot assume the column is present.
This would require the new application code to conditionally handle either case, adding complexity, or more likely, spreading out the change over two releases (adding the column in the first release and then using it in the second).
The tradeoff is that the old application code need not work with the new column since it would never be run with it present.&lt;/p&gt;

&lt;p&gt;The benefit of the post-migration approach is more apparent when we consider the example of removing a column (ignoring the specific issues that stem from Rails caching columns that necessitate &lt;a href=&quot;https://github.com/rails/rails/pull/21720&quot;&gt;ignoring columns&lt;/a&gt; prior to dropping them even when the application no longer uses the column).&lt;/p&gt;

&lt;p&gt;In the pre-migration approach, the column is removed before the new code is deployed.
This would necessitate the old code to work without the column that is about to be removed, which would require conditionally handling either case (again adding complexity), or more commonly, would require two releases.&lt;/p&gt;

&lt;p&gt;In the post-migration approach, the new code is deployed before the column is removed so it can be safely dropped as no running apps will attempt to use it.&lt;/p&gt;

&lt;p&gt;If you had to pick between having either pre- or post-migrations only, it’s more common to choose pre-migrations since applications additive changes like adding columns are usually more common than subtractive changes like removing columns.&lt;/p&gt;

&lt;h3 id=&quot;both-pre--and-post-deploy-migrations&quot;&gt;Both pre- and post-deploy migrations&lt;/h3&gt;

&lt;p&gt;Given the tradeoffs to these approaches, there is of course another approach possible: to run some migrations before the new code is deployed and some after.&lt;/p&gt;

&lt;p&gt;This approach has added complexity since most database migration tooling (e.g. Active Record migrations) is built with the assumption of just running all of the migrations available.&lt;/p&gt;

&lt;p&gt;There is also conceptual overhead required in having to think through when any particular migration should be run and how to handle rollbacks.&lt;/p&gt;

&lt;p&gt;This approach also still has the problem of long-running migrations holding up an app release.&lt;/p&gt;

&lt;h2 id=&quot;zero-coupling&quot;&gt;Zero-coupling&lt;/h2&gt;

&lt;p&gt;In all of the previously mentioned approaches, performing the database migration at a specified point during a release along with an application deploy affords not having to maintain either backwards- or forwards-compatibility (though not both except in the first case).&lt;/p&gt;

&lt;p&gt;Of course, it is possible to forgo this affordance and instead strive for both backwards- and forwards-compatibility even when not strictly necessary, removing the problem of having to rollback the application and database together.&lt;/p&gt;

&lt;p&gt;However once you do that, you might as well consider one final possible approach: to fully decouple application and database changes so that either can occur in isolation.&lt;/p&gt;

&lt;p&gt;A simple way of implementing this approach while keeping a single release pipeline would be to have each release contain either application changes or database changes, but not both.&lt;/p&gt;

&lt;p&gt;This would require maintaining both backwards- and forwards-compatibility, which adds some conceptual overhead, but also provides confidence for rollbacks.&lt;/p&gt;

&lt;p&gt;Each change could also be rolled back in isolation since at any point:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;when deploying the application, the database must support both the old and new application versions&lt;/li&gt;
  &lt;li&gt;when migrating the database, the application must support both the old and new database versions&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If some additional work is taken to separate the release pipelines, this approach could provide the capability to deploy application changes at any time, whether a database migration is currently running or not.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Each approach outlined above has tradeoffs. As coupling decreases, the conceptual overhead required to understand the necessary backwards- and/or forwards-compatibility quickly increases.&lt;/p&gt;

&lt;p&gt;It’s often assumed that the work necessary to decouple application changes from database changes is not worth pursuing until reaching a certain scale, but as soon as they are partially decoupled (for zero-downtime deployment), it becomes essential to consider the need for backwards- and forwards-compatibility. I believe that it may prove to be worth it to expend the additional effort to fully decouple application and database changes early on to establish good habits and provide confidence for rollbacks.&lt;/p&gt;

&lt;p&gt;Whichever approach you take, it’s important to understand the possible problems that can emerge from the fundamental problem of the database and application not existing as a single entity that can be changed atomically.&lt;/p&gt;

&lt;h2 id=&quot;prior-work&quot;&gt;Prior work&lt;/h2&gt;

&lt;p&gt;The following blog posts greatly helped me formulate my thoughts more concretely on this subject:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Philip Potter - &lt;a href=&quot;http://www.philandstuff.com/2018/04/04/keep-database-deploys-separate.html&quot;&gt;Keep database deploys separate&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Michael Brunton-Spall - &lt;a href=&quot;http://www.brunton-spall.co.uk/post/2014/05/06/database-migrations-done-right/&quot;&gt;Database Migrations Done Right&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Philip I. Thomas - &lt;a href=&quot;https://blog.staffjoy.com/dont-migrate-databases-automatically-5039ab061365&quot;&gt;Don’t Migrate Databases Automatically&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Maxwell Holder</name></author><summary type="html">Most web applications use a database to persist state. Since the database is separate from the application and changes cannot be made to both simultaneously, there are various strategies for keeping them in sync.</summary></entry><entry><title type="html">Silencing tzinfo-data Bundler warnings</title><link href="http://localhost:4000/2019/01/04/tzinfo-data-warning.html" rel="alternate" type="text/html" title="Silencing tzinfo-data Bundler warnings" /><published>2019-01-04T14:24:37-08:00</published><updated>2019-01-04T14:24:37-08:00</updated><id>http://localhost:4000/2019/01/04/tzinfo-data-warning</id><content type="html" xml:base="http://localhost:4000/2019/01/04/tzinfo-data-warning.html">&lt;p&gt;If you’ve ever created a new &lt;a href=&quot;https://rubyonrails.org/&quot;&gt;Rails&lt;/a&gt; app and then ran &lt;code class=&quot;highlighter-rouge&quot;&gt;bundle install&lt;/code&gt; on a Unix-like system, you’ve probably seen this warning:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The dependency tzinfo-data (&amp;gt;= 0) will be unused by any of the platforms Bundler is installing for. Bundler is installing for ruby but the dependency is only for x86-mingw32, x86-mswin32, x64-mingw32, java. To add those platforms to the bundle, run bundle lock –add-platform mingw, mswin, x64_mingw, jruby.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is a classic example of a noisy warning.&lt;/p&gt;

&lt;p&gt;Bundler is trying to be helpful and telling you that you have a gem in your Gemfile that it’s not going to install because it’s marked as only being for certain platforms.&lt;/p&gt;

&lt;p&gt;Usually, this is a good thing: it can be &lt;a href=&quot;https://github.com/bundler/bundler/pull/5003&quot;&gt;confusing&lt;/a&gt; if Bundler skips gems listed in your Gemfile without telling you why.&lt;/p&gt;

&lt;p&gt;In this case, it’s not so helpful.&lt;/p&gt;

&lt;p&gt;Rails includes this gem because it needs to be able to do timezone conversions and the library it uses (&lt;a href=&quot;https://tzinfo.github.io/&quot;&gt;tzinfo&lt;/a&gt;) depends on having timezone definitions available.&lt;/p&gt;

&lt;p&gt;On Unix-like systems, these are usually provided by the system itself so the tzinfo gem will just use those.
Windows, however, does not provide these definitions so the tzinfo-data gem needs to be included to provide them instead.&lt;/p&gt;

&lt;h2 id=&quot;how-to-silence-these-warnings&quot;&gt;How to silence these warnings&lt;/h2&gt;

&lt;p&gt;Fortunately, Bundler (versions &amp;gt;= 1.17.0) has an &lt;a href=&quot;https://bundler.io/v1.17/bundle_config.html&quot;&gt;option&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;disable_platform_warnings&lt;/code&gt; for silencing these warnings.&lt;/p&gt;

&lt;p&gt;You can set it for a specific app by running:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bundle config &lt;span class=&quot;nt&quot;&gt;--local&lt;/span&gt; disable_platform_warnings &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Every developer has to do this individually since Rails git ignores the &lt;code class=&quot;highlighter-rouge&quot;&gt;.bundle&lt;/code&gt; directory where this config is stored (which is &lt;a href=&quot;https://stackoverflow.com/questions/6963496/why-does-rails-ignore-bundle-by-default&quot;&gt;intentional&lt;/a&gt; since most of the options used for configuring Bundler have to do with the local system e.g. gem installation options specific to a machine).&lt;/p&gt;

&lt;p&gt;If you leave off the &lt;code class=&quot;highlighter-rouge&quot;&gt;--local&lt;/code&gt; option, the warnings will be silenced globally for the current machine, regardless of which project you’re in.&lt;/p&gt;

&lt;p&gt;This is preferable to &lt;a href=&quot;https://github.com/tzinfo/tzinfo-data/issues/12#issuecomment-279554001&quot;&gt;other ways&lt;/a&gt; to avoid seeing this warning since it keeps the app working in Windows and doesn’t install unneeded dependencies on non-Windows systems.&lt;/p&gt;</content><author><name>Maxwell Holder</name></author><summary type="html">If you’ve ever created a new Rails app and then ran bundle install on a Unix-like system, you’ve probably seen this warning: The dependency tzinfo-data (&amp;gt;= 0) will be unused by any of the platforms Bundler is installing for. Bundler is installing for ruby but the dependency is only for x86-mingw32, x86-mswin32, x64-mingw32, java. To add those platforms to the bundle, run bundle lock –add-platform mingw, mswin, x64_mingw, jruby.</summary></entry></feed>